import RsTools.FormMorph as rtf
reload(rtf)
import rhinoscriptsyntax as rs
import Rhino
from Rhino.Geometry import *

CLEAR_ON_RESET=False
GENLAYER='SHAPE_GRAMMAR_GENERATED_OBJECTS'
ENABLEDARAW=False
TAKESNAPSHOTS=False

rs.AddLayer(GENLAYER)

class Geometry():
    def __init__(self, guid, position=None, vects=None, size=None, name='',parent=None):
        self.guid=guid
        self.name=name
        flag=True
        if position is None and vects is None and size is None:
            self.get_shape(guid)
            flag=False
        else:
            self.size=Vector3d(size)
            self.position=Point3d(position)
            #self.rotate=Vector3d(0,0,0)
            self.vects=[]
            for v in vects:
                self.vects.append(Vector3d(v))

        self._parent=None
        self.children = []
        if parent is not None:
            self.set_parent(parent)

    def __str__(self):
        return '{}<vects:({})>'.format(self.name,_str_vects(self.vects))
        #return '{}<pos:({}),size:{},vectsu:({}),id:{}>'.format(
        #    self.name, self.position,self.size,self.vects[0],self.guid)

    def print_tree(self,level=0):
        prefix='        '*level
        print(prefix+str(self))
        for c in self.children:
            c.print_tree(level+1)

    @property
    def root(self):
        if self._parent is None:
            return self
        return self._parent.root

    def set_parent(self,parent):
        self._parent=parent
        self._parent.children.append(self)

    def get_shape(self, guid):
        #override
        pass

    def get_vect(self,direction, unitized=True):
        if unitized:
            return self.vects[direction]
        else:
            return self.vects[direction]*self.size[direction]

    def get_length(self,direction):
        return self.vects[direction].Length

class ShapeBox(Geometry):
    def get_shape(self, guid):
        flag,org_vect=rtf.is_solid_box(guid)
        if flag:
            self.position=Point3d(org_vect[0])
            vu = org_vect[1]
            vv = org_vect[2]
            vw = org_vect[3]
            self.size=Vector3d(vu.Length,vv.Length,vw.Length)
            self.vects=[rs.VectorUnitize(vu),
                        rs.VectorUnitize(vv),
                        rs.VectorUnitize(vw)]
    pass

class Engine():
    def __init__(self):
        self.data=[]

    def clear(self):
        trash = rs.ObjectsByLayer(GENLAYER)
        if len(trash) > 0:
            rs.DeleteObjects(trash)

    def _snap(self):
        pass

    def take_snap_shot(self,flag=True):
        TAKESNAPSHOTS=flag

    def add(self,obj):
        self.data.append(obj)

    def add_multiple(self,objs):
        self.data+=objs

    def add_name(self, name):
        sel = rs.ObjectsByName(name)
        if len(sel) > 0:
            for id in sel:
                obj = ShapeBox(id,name=name)
                self.data.append(obj)


    def delete(self,obj):
        index=self.data.index(obj)
        if index>0:
            del self.data[index]
        try:
            rs.DeleteObject(obj.guid)
            obj.guid = None
        except:
            print('unable to delete')
            pass

    def recursion(self,callback,repetition,name):
        temp='AUTOGENERATEDTEMP'
        self.rename(name,temp)
        for i in range(repetition):
            iname = str(i)
            self.rename(temp, iname)
            callback(iname)
            self.rename(iname + 'output', temp)
        return temp

    def print_data(self):
        for o in self.data:
            print(o)

    def print_tree(self):
        for o in self.data:
            if o._parent is None:
                o.print_tree()



    def get_by_name(self,name, return_index=False):
        basket=[]
        indice=[]
        for i in range(len(self.data)):
            o=self.data[i]
            if o.name==name:
                basket.append(o)
                indice.append(i)
        if return_index:
            return basket,indice
        return basket
    def delete_objects(self, objs):
        for o in objs:
            i=self.data.index(o)
            if i>0:
                del self.data[i]
                rs.DeleteObject(o.guid)


    def delete_name(self,name):
        for o in self.data:
            if o.name==name:
                self.delete(o)

    def replace(self,index,obj):
        try:
            id=self.data[index].guid
            rs.DeleteObject(id)
        except:
            print('failed to delete object ',id)

        self.data[index]=obj

    def rename(self,name,out_name):
        objs, indice = self.get_by_name(name, return_index=True)
        basket = []
        for o in objs:
            o.name=out_name
            basket.append(o)
        return basket

    def scale(self,name,scales,centered=True,out_name=None):
        objs,indice=self.get_by_name(name,return_index=True)
        basket=[]
        for o,i in zip(objs,indice):
            shape=scale(o,scales,centered)
            basket.append(shape)
            if out_name:
                shape.name=out_name
                self.add(shape)
            else:
                shape.name=name
                self.replace(i,shape)
        if TAKESNAPSHOTS:
            self._snap()
        return basket

    def _move_object(self,obj,transform):
        rs.MoveObject(obj.guid, transform)
        obj.position += transform

    def copy(self,name,out_name):
        objs, indice = self.get_by_name(name, return_index=True)
        basket=[]
        for o in objs:
            dup=self.create_box(o.position,o.vects,o.size,out_name)
            basket.append(dup)
        return basket

    def move(self,name,transform,ratio_mode=True):

        objs, indice = self.get_by_name(name, return_index=True)
        for o in objs:
            trans=Vector3d(0,0,0)
            for i in range(3):
                v=rs.VectorScale(o.vects[i],transform[i])
                if ratio_mode:
                    v=v*o.size[i]

                trans+=v

            rs.MoveObject(o.guid,trans)
            o.position+=trans

        if TAKESNAPSHOTS:
            self._snap()

    def create_box(self,position, vects, size, name=''):
        box=create_box(position,vects,size,name=name,preserve_vectors=True)
        rs.ObjectLayer(box.guid,GENLAYER)
        self.add(box)
        return box

    def invert(self,name,direction):
        objs=self.get_by_name(name)
        for o in objs:
            print('inverting {}'.format(name))
            invert_obj(o,direction)

    def bisect_mirror(self,name,div,out_names,direction=1,
                      ratio_mode=True,delete_input=True):
        objs = ENGINE.get_by_name(name)
        left = '_1100'
        right = '_2200'
        middle = '_3200'
        for o in objs:
            if ratio_mode:
                length=1.0
            else:
                length=o.size(direction)
            if div<length/2:
                divs=[div,length-(div*2),div]
                tempnames = [left, middle, right]
            else:
                divs=[length/2,length/2]
                tempnames = [left, right]

            #print(divs)
            basket=_divide_object(self, o, divs, tempnames, direction, ratio_mode)
            invert_obj(basket[-1],direction)
            print(str(basket[-1]))



            i = 0
            for name in tempnames:
                j=i%len(out_names)
                oname=out_names[j]
                self.rename(name,oname)
                i+=1


        if delete_input:
            self.delete_objects(objs)
        else:
            for o in objs:
                rs.HideObject(o.guid)
        if TAKESNAPSHOTS:
            self._snap()



    def divide(self, name, divs=[0.5, 0.5], out_names=['box_A'],
               scale_u=None,scale_v=None,scale_w=None,
              direction=0, ratio_mode=True, delete_input=True):
        if name is None:
            objs=[]
            for o in ENGINE.data:
                if o.guid is not None:
                    objs.append(o)
        else:
            objs = ENGINE.get_by_name(name)

        for o in objs:
            if divs[-1]=='r':
                length=o.size[direction]
                adj_divs=get_recursove_ratios(length,divs,ratio_mode)
            else:
                adj_divs = divs
            _divide_object(self,o,adj_divs,out_names,direction,ratio_mode)

        if delete_input:
            self.delete_objects(objs)
        else:
            for o in objs:
                rs.HideObject(o.guid)
        if TAKESNAPSHOTS:
            self._snap()

ENGINE=Engine()

def _str_vects(vects):
    txt=''
    for v in vects:
        t='(%4.1f,%4.2f,%4.2f) '%(v[0],v[1],v[2])
        txt+=t
    return txt



def _divide_object(engine,obj,divs,out_names,direction,ratio_mode):
    unitize=not ratio_mode
    adj_divs=divs
    o=obj
    basket=[]
    trans = Vector3d(0, 0, 0)
    for i in range(len(adj_divs)):
        div = adj_divs[i]

        j = i % len(out_names)
        vect = o.get_vect(direction, unitize) * div
        length = o.get_length(direction)
        # scales
        if ratio_mode:
            scales = [1, 1, 1]
            scales[direction] = div
            size = (scales[0] * o.size[0], scales[1] * o.size[1], scales[2] * o.size[2])
        else:
            size = [o.size[0], o.size[1], o.size[2]]
            size[direction] = div

        if i > 0:
            trans += o.get_vect(direction, unitize) * adj_divs[i - 1]

            # trans = o.get_vect(direction, unitize) * adj_divs[i-1]

        oname = out_names[j]
        pos = o.position + Vector3d(trans[0], trans[1], trans[2])
        box = engine.create_box(pos, o.vects, Point3d(size[0],size[1],size[2]), oname)

        box.set_parent(o)
        basket.append(box)
    return basket

def create_box(position, vects, size, name='',preserve_vectors=False):
    org = position
    u = vects[0] * size[0]
    v = vects[1] * size[1]
    w = vects[2] * size[2]
    pts = []
    pts.append(org)
    pts.append(org + u)
    pts.append(org + u + v)
    pts.append(org + v)
    pts.append(org)

    poly = rs.AddPolyline(pts)
    brep = rs.ExtrudeCurveStraight(poly, org, org + w)
    rs.CapPlanarHoles(brep)
    rs.DeleteObjects([poly])
    rs.ObjectLayer(brep,GENLAYER)
    #print(name,preserve_vectors)
    if preserve_vectors:
        box = ShapeBox(brep,position,vects,size,name)
    else:
        box = ShapeBox(brep,name=name)
    return box

def add_Box(names):
    for name in names:
        sel = rs.ObjectsByName(name)
        if len(sel)>0:
            for id in sel:
                obj=ShapeBox(id)

                ENGINE.add(obj)

def clear():
    trash=rs.ObjectsByLayer(GENLAYER)
    if len(trash)>0:
        rs.DeleteObjects(trash)

def invert_obj(obj,direction):
    #print('< before '+str(list(obj.vects[direction])))
    obj.position = Point3d(obj.position+(obj.vects[direction]*obj.size[direction]))
    obj.vects[direction]=Vector3d(obj.vects[direction]*-1)
    #print('> after ' + str(list(obj.vects[direction])))

def scale(obj,scales,centered=True):
    o=obj
    org=o.position
    u = o.get_vect(0)
    v = o.get_vect(1)
    w = o.get_vect(2)

    su = u * scales[0]
    sv = v * scales[1]
    sw = w * scales[2]
    #print(list(org))
    if centered:
        ou = ((su - u) / 2) * o.size[0]
        ov = ((sv - v) / 2) * o.size[1]
        #ow = (su - w) / 2
        org=org-ou-ov
    #print('centered:', centered, list(org))
    pos=org
    vects=(u,v,w)
    size=(o.size[0]*scales[0],
          o.size[1]*scales[1],
          o.size[2]*scales[2])
    box=create_box(pos,vects,size)
    return box





def get_recursove_ratios(length, divs, ratio_mode=True):
    org_ratios = divs[:-1]
    if length==0:
        print('length is zero')
        return
    odivs = []
    total=0
    i=0
    while total<length:
        j=i%len(org_ratios)
        odivs.append(org_ratios[j])
        if ratio_mode:
            total+=(odivs[i] * length)
        else:
            total+=odivs[i]
        i+=1
    #print(length,len(odivs))
    return odivs



def copy(name,out_name,trans=None):
    sel=rs.ObjectsByName(name)
    if sel is None or len(sel)<1:
        print('\"'+name + '\" is not defined')

    for o in sel:
        out_o=rs.CopyObject(o)
        rs.ObjectName(out_o,out_name)
        rs.ObjectLayer(out_o,GENLAYER)

        if trans is not None:
            flag, org_vect = rtf.is_solid_box(out_o)
            if flag:
                vu = org_vect[1] * trans[0]
                vv = org_vect[2] * trans[1]
                vw = org_vect[3] * trans[2]
                trans = vu + vv + vw
                rs.MoveObject(out_o, trans)

def move(name,transform=[0,0,0]):
    sel = rs.ObjectsByName(name)
    if sel is None or len(sel) < 1:
        print('\"' + name + '\" is not defined')

    for o in sel:
        flag,org_vects=rtf.is_solid_box(o)
        if flag:
            rtf.move(o,transform,org_vects)

def _scale(name,scales=[1,1,1],centered=True,ratio_mode=True):
    sel = rs.ObjectsByName(name)
    if sel is None or len(sel) < 1:
        print('\"' + name + '\" is not defined')

    for o in sel:
        flag,org_vect=rtf.is_solid_box(o)
        if flag:
            out_o=rtf.genbox_from_org_vects(org_vect,scales,centered,ratio_mode)
            rs.ObjectName(out_o,name)
            rs.ObjectLayer(out_o,GENLAYER)

    rs.DeleteObjects(sel)



