import RsTools.FormMorph as rtf
reload(rtf)
import rhinoscriptsyntax as rs
import Rhino
import Rhino.Geometry as rg
from Rhino.Geometry import *

CLEAR_ON_RESET=False
GENLAYER='SHAPE_GRAMMAR_GENERATED_OBJECTS'
ENABLEDARAW=False
TAKESNAPSHOTS=False

rs.AddLayer(GENLAYER)

class Geometry():
    def __init__(self, guid, position=None, vects=None, size=None, name='',parent=None):
        self.guid=guid
        self.name=name
        flag=True
        if position is None and vects is None and size is None:
            self.get_shape(guid)
            flag=False
        else:
            self.size=Vector3d(size)
            self.position=Point3d(position)
            #self.rotate=Vector3d(0,0,0)
            self.vects=[]
            for v in vects:
                self.vects.append(Vector3d(v))

        self._parent=None
        self.children = []
        if parent is not None:
            self.set_parent(parent)

    def __str__(self):
        return '{}<vects:({},{})>'.format(self.name,_str_vects(self.vects),list(self.size))
        #return '{}<pos:({}),size:{},vectsu:({}),id:{}>'.format(
        #    self.name, self.position,self.size,self.vects[0],self.guid)

    def print_tree(self,level=0):
        prefix='    '*level
        print(prefix+str(self))
        for c in self.children:
            c.print_tree(level+1)

    @property
    def root(self):
        if self._parent is None:
            return self
        return self._parent.root

    def set_parent(self,parent):
        self._parent=parent
        self._parent.children.append(self)

    def get_shape(self, guid):
        #override
        pass

    def get_vect(self,direction, unitized=True):
        if unitized:
            return self.vects[direction]
        else:
            return self.vects[direction]*self.size[direction]

    def get_length(self,direction):
        return self.vects[direction].Length




class ShapeBox(Geometry):
    def get_shape(self, guid):
        flag,org_vect=rtf.is_solid_box(guid)
        if flag:
            self.position=Point3d(org_vect[0])
            vu = org_vect[1]
            vv = org_vect[2]
            vw = org_vect[3]
            self.size=Vector3d(vu.Length,vv.Length,vw.Length)
            self.vects=[rs.VectorUnitize(vu),
                        rs.VectorUnitize(vv),
                        rs.VectorUnitize(vw)]
    pass

class Engine():
    def __init__(self):
        self.data=[]

    def clear(self):
        trash = rs.ObjectsByLayer(GENLAYER)
        if len(trash) > 0:
            rs.DeleteObjects(trash)

    def _snap(self):
        pass

    def take_snap_shot(self,flag=True):
        TAKESNAPSHOTS=flag

    def add(self,obj):
        self.data.append(obj)

    def add_multiple(self,objs):
        self.data+=objs

    def add_name(self, name):
        sel = rs.ObjectsByName(name)
        if len(sel) > 0:
            for id in sel:
                obj = ShapeBox(id,name=name)
                self.data.append(obj)


    def delete(self,obj):
        index=self.data.index(obj)
        if index>0:
            del self.data[index]
        try:
            rs.DeleteObject(obj.guid)
            obj.guid = None
        except:
            print('unable to delete')
            pass

    def decompose(self,name,out_names=['front','back','left','right','top','bot'],prefix=''):
        pass

    def recursion(self,callback,repetition,name):
        temp='AUTOGENERATEDTEMP'
        self.rename(name,temp)
        for i in range(repetition):
            iname = str(i)
            self.rename(temp, iname)
            callback(iname)
            self.rename(iname + 'output', temp)
        return temp

    def print_data(self):
        for o in self.data:
            print(o)

    def print_tree(self):
        for o in self.data:
            if o._parent is None:
                o.print_tree()



    def get_by_name(self,name, return_index=False):
        basket=[]
        indice=[]
        for i in range(len(self.data)):
            o=self.data[i]
            if o.name==name:
                basket.append(o)
                indice.append(i)
        if return_index:
            return basket,indice
        return basket
    def delete_objects(self, objs):
        for o in objs:
            i=self.data.index(o)
            if i>0:
                del self.data[i]
                rs.DeleteObject(o.guid)


    def delete_name(self,name):
        for o in self.data:
            if o.name==name:
                self.delete(o)

    def replace(self,index,obj):
        try:
            id=self.data[index].guid
            rs.DeleteObject(id)
        except:
            print('failed to delete object ',id)

        self.data[index]=obj

    def rename(self,name,out_name):
        objs, indice = self.get_by_name(name, return_index=True)
        basket = []
        for o in objs:
            o.name=out_name
            basket.append(o)
        return basket



    #creation

    def create_box_(self, size, name):
        size = Vector3d(size[0], size[1], size[2])
        vects = [Vector3d(0, 1, 0), Vector3d(-1, 0, 0), Vector3d(0, 0, 1)]
        return self.create_box(Point3d(0, 0, 0), vects, size, name=name)

    def create_box(self,position, vects, size, name=''):
        box=create_box(position,vects,size,name=name,preserve_vectors=True)
        rs.ObjectLayer(box.guid,GENLAYER)
        self.add(box)
        box.name=name
        return box

    #transformation
    def scale(self,name,scales,centered=True,out_name=None):
        objs,indice=self.get_by_name(name,return_index=True)
        basket=[]
        for o,i in zip(objs,indice):
            shape=scale(o,scales,centered)
            basket.append(shape)
            if out_name:
                shape.name=out_name
                self.add(shape)
            else:
                shape.name=name
                self.replace(i,shape)
        if TAKESNAPSHOTS:
            self._snap()
        return basket

    def _move_object(self,obj,transform):
        rs.MoveObject(obj.guid, transform)
        obj.position += transform


    def move(self,name,transform,ratio_mode=True):

        objs, indice = self.get_by_name(name, return_index=True)
        for o in objs:
            trans=Vector3d(0,0,0)
            for i in range(3):
                v=rs.VectorScale(o.vects[i],transform[i])
                if ratio_mode:
                    v=v*o.size[i]

                trans+=v

            rs.MoveObject(o.guid,trans)
            o.position+=trans

        if TAKESNAPSHOTS:
            self._snap()


    def invert(self,name,direction):
        objs=self.get_by_name(name)
        for o in objs:
            #print('inverting {}'.format(name))
            invert_obj(o,direction)

    #operations
    def copy(self,name,out_name):
        objs, indice = self.get_by_name(name, return_index=True)
        basket=[]
        for o in objs:
            dup=self.create_box(o.position,o.vects,o.size,out_name)
            dup.set_parent(o)
            basket.append(dup)
        return basket

    def bisect_mirror(self,name,div,out_names,direction=1,
                      ratio_mode=True,delete_input=True):
        rs.EnableRedraw(False)
        objs = ENGINE.get_by_name(name)
        left = '_1100'
        right = '_2200'
        middle = '_3200'
        for o in objs:
            if ratio_mode:
                length=1.0
            else:
                length=o.size(direction)
            if div<length/2:
                divs=[div,length-(div*2),div]
                tempnames = [left, middle, right]
            else:
                divs=[length/2,length/2]
                tempnames = [left, right]

            #print(divs)
            basket=_divide_object(self, o, divs, tempnames, direction, ratio_mode)
            invert_obj(basket[-1],direction)
            #print(str(basket[-1]))



            i = 0
            for name in tempnames:
                j=i%len(out_names)
                oname=out_names[j]
                self.rename(name,oname)
                i+=1


        if delete_input:
            self.delete_objects(objs)
        else:
            for o in objs:
                rs.HideObject(o.guid)
        if TAKESNAPSHOTS:
            self._snap()
        if ENABLEDARAW:
            rs.EnableRedraw(True)


    def divide(self, name, divs=[0.5, 0.5], out_names=['box_A'],
              direction=0, ratio_mode=True, delete_input=True,
               min_size=None, recursion_count=0,
               recursion_max=100,force_recursion=False):
        rs.EnableRedraw(False)

        if isinstance(name,basestring):
            objs = ENGINE.get_by_name(name)
        elif isinstance(name,list):
            if isinstance(name[0],ShapeBox):
                objs=name
                name=objs[0].name
        else:
            return

        #for each given object
        for o in objs:
            #terminal conditions:
            if min_size is not None:
                if o.size[direction]<min_size:
                    #print('terminal con: size less then given minimum')
                    continue

            if not ratio_mode:
                if o.size[direction]<divs[0]:
                    #print('terminal con: size less then first div width')
                    continue

            #actual rule body
            if divs[-1]=='r':
                length=o.size[direction]
                adj_divs=get_recursive_ratios(length,divs,ratio_mode)
            else:
                adj_divs = divs
            out_objs=_divide_object(self,o,adj_divs,out_names,direction,ratio_mode)

            sel=[]
            #print(out_names)
            for oo in out_objs:
                if oo.name==name:
                    sel.append(oo)

            #recursion
            if min_size is None:
                min_size=1
            if len(sel)>0:
                if recursion_count < recursion_max:
                    self.divide(sel,divs,out_names,direction,ratio_mode,True,
                                min_size=min_size,
                                recursion_count=recursion_count+1)
                else:
                    #print('exceeded recursion max')
                    continue
            else:
                #print('name not found for recursion')
                pass

        if delete_input:
            self.delete_objects(objs)
        else:
            for o in objs:
                rs.HideObject(o.guid)

        if TAKESNAPSHOTS:
            self._snap()
        if ENABLEDARAW:
            rs.EnableRedraw(True)

    pass


ENGINE=Engine()

def is_solid_box(brepid):
    # strictly checks if the brep is a solid box
    # returns bool,org_vect
    # org_vect is a list of
    # [Point3d:org, Vector3d u, Vector3d v, Vector3d h]
    # vectors are not unitized
    brep = rs.coercebrep(brepid)

    if not brep.IsSolid:
        return False,None
    counter = 0
    edges = []
    edge_pts=[]
    pts_low=None
    pts_high=None
    for f in brep.Faces:
        counter += 1
        if counter > 6:
            return False
        flag, plane = f.TryGetPlane()
        #gets the top or bottom plane
        if flag:
            if plane.ZAxis[2] == 1 or plane.ZAxis[2] == -1:
                pts=[]
                egs=rg.PolyCurve()
                for e in f.AdjacentEdges():
                    p=brep.Edges[e].PointAtStart
                    pts.append(p)
                    egs.Append(brep.Edges[e])
                edges.append(egs)
                edge_pts.append(pts)

            if pts_low is None:
                pts_low = pts
                pts_high =pts
            elif pts[0].Z>pts_low[0].Z:
                pts_high=pts
            else:
                pts_low=pts
        else:
            return False

    #now edge_pts should contains 8 points


    if counter == 6:
        #print(edge_pts[0][0],edge_pts[1][0])
        if edge_pts[0][0].Z>edge_pts[1][0].Z:
            arrx= edges[0].ClosestPoint(edge_pts[1][0])
            cp = edges[0].PointAt(arrx[1])
            w = cp-edge_pts[1][0]
            org = edge_pts[1][0]
        else:
            arrx= edges[1].ClosestPoint(edge_pts[0][0])
            cp=edges[1].PointAt(arrx[1])
            w = cp - edge_pts[0][0]
            org = edge_pts[0][0]
        u=edge_pts[0][1]-edge_pts[0][0]
        v=edge_pts[0][2]-edge_pts[0][1]

        if u.Length>v.Length:
            t=v
            v=u
            u=t
        return True,(org,u,v,w)
    return False,None


def _str_vects(vects):
    txt=''
    for v in vects:
        t='(%4.1f,%4.2f,%4.2f) '%(v[0],v[1],v[2])
        txt+=t
    return txt



def _divide_object(engine,obj,divs,out_names,direction,ratio_mode):
    unitize=not ratio_mode
    adj_divs=divs
    o=obj
    basket=[]
    trans = Vector3d(0, 0, 0)
    for i in range(len(adj_divs)):
        div = adj_divs[i]

        j = i % len(out_names)
        vect = o.get_vect(direction, unitize) * div
        length = o.get_length(direction)
        # scales
        if ratio_mode:
            scales = [1, 1, 1]
            scales[direction] = div
            size = (scales[0] * o.size[0], scales[1] * o.size[1], scales[2] * o.size[2])
        else:
            size = [o.size[0], o.size[1], o.size[2]]
            size[direction] = div

        if i > 0:
            trans += o.get_vect(direction, unitize) * adj_divs[i - 1]

            # trans = o.get_vect(direction, unitize) * adj_divs[i-1]

        oname = out_names[j]
        pos = o.position + Vector3d(trans[0], trans[1], trans[2])
        box = engine.create_box(pos, o.vects, Point3d(size[0],size[1],size[2]), oname)

        box.set_parent(o)
        basket.append(box)
    return basket


def create_box_(size,name):
    size=Vector3d(size[0],size[1],size[2])
    vects=[Vector3d(0,1,0),Vector3d(1,0,0),Vector3d(0,0,1)]
    create_box(Point3d(0,0,0),vects,size,name=name,presrve_vectors=True)


def create_box(position=Point3d(0,0,0), vects=[Vector3d(0,1,0),Vector3d(1,0,0),Vector3d(0,0,1)], size=Vector3d(20,50,60), name='',preserve_vectors=False):
    org = position

    u = vects[0] * size[0]
    v = vects[1] * size[1]
    w = vects[2] * size[2]
    pts = []
    pts.append(org)
    pts.append(org + u)
    pts.append(org + u + v)
    pts.append(org + v)
    pts.append(org)

    poly = rs.AddPolyline(pts)
    brep = rs.ExtrudeCurveStraight(poly, org, org + w)
    rs.CapPlanarHoles(brep)
    rs.DeleteObjects([poly])
    rs.ObjectLayer(brep,GENLAYER)
    #print(name,preserve_vectors)
    if preserve_vectors:
        box = ShapeBox(brep,position,vects,size,name)
    else:
        box = ShapeBox(brep,name=name)
    return box

def add_Box(names):
    for name in names:
        sel = rs.ObjectsByName(name)
        if len(sel)>0:
            for id in sel:
                obj=ShapeBox(id)

                ENGINE.add(obj)

def clear():
    trash=rs.ObjectsByLayer(GENLAYER)
    if len(trash)>0:
        rs.DeleteObjects(trash)

def invert_obj(obj,direction):
    #print('< before '+str(list(obj.vects[direction])))
    obj.position = Point3d(obj.position+(obj.vects[direction]*obj.size[direction]))
    obj.vects[direction]=Vector3d(obj.vects[direction]*-1)
    #print('> after ' + str(list(obj.vects[direction])))

def scale(obj,scales,centered=True):
    o=obj
    org=o.position
    u = o.get_vect(0)
    v = o.get_vect(1)
    w = o.get_vect(2)

    su = u * scales[0]
    sv = v * scales[1]
    sw = w * scales[2]
    #print(list(org))
    if centered:
        ou = ((su - u) / 2) * o.size[0]
        ov = ((sv - v) / 2) * o.size[1]
        #ow = (su - w) / 2
        org=org-ou-ov
    #print('centered:', centered, list(org))
    pos=org
    vects=(u,v,w)
    size=(o.size[0]*scales[0],
          o.size[1]*scales[1],
          o.size[2]*scales[2])
    box=create_box(pos,vects,size)
    return box

def get_recursive_ratios(length, divs, ratio_mode=True):
    divs=divs[:-1]
    if length==0:
        print('length is zero')
        return

    total = 0
    for div in divs:
        total += div
    if total < length:
        if ratio_mode:
            last=1-total
            divs.append(last)
        else:
            last=length-total
            divs.append(last)
    return divs


def copy(name,out_name,trans=None):
    sel=rs.ObjectsByName(name)
    if sel is None or len(sel)<1:
        print('\"'+name + '\" is not defined')

    for o in sel:
        out_o=rs.CopyObject(o)
        rs.ObjectName(out_o,out_name)
        rs.ObjectLayer(out_o,GENLAYER)

        if trans is not None:
            flag, org_vect = rtf.is_solid_box(out_o)
            if flag:
                vu = org_vect[1] * trans[0]
                vv = org_vect[2] * trans[1]
                vw = org_vect[3] * trans[2]
                trans = vu + vv + vw
                rs.MoveObject(out_o, trans)

def move(name,transform=[0,0,0]):
    sel = rs.ObjectsByName(name)
    if sel is None or len(sel) < 1:
        print('\"' + name + '\" is not defined')

    for o in sel:
        flag,org_vects=rtf.is_solid_box(o)
        if flag:
            rtf.move(o,transform,org_vects)

def _scale(name,scales=[1,1,1],centered=True,ratio_mode=True):
    sel = rs.ObjectsByName(name)
    if sel is None or len(sel) < 1:
        print('\"' + name + '\" is not defined')

    for o in sel:
        flag,org_vect=rtf.is_solid_box(o)
        if flag:
            out_o=rtf.genbox_from_org_vects(org_vect,scales,centered,ratio_mode)
            rs.ObjectName(out_o,name)
            rs.ObjectLayer(out_o,GENLAYER)

    rs.DeleteObjects(sel)



